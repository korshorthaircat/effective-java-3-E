# 44. 스트림은 주의해서 사용하라

>스트림과 반복문 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라.

- - - 
## 스트림 api의 주요 개념
### 스트림(stream)
* 의미: 데이터 원소의 유한 혹은 무한 시퀀스(sequence)
* 스트림의 원소들은…
    * 컬렉션, 배열, 파일, 정규표현식 패턴 매처(matcher), 난수 생성기, 다른 스트림 등에서 온다.
    * 객체 참조나 기본타입(int, long, double) 값이다.
### 스트림 파이프라인(stream pipeline)
* 의미: 스트림의 원소들로 수행하는 연산단계
* 특징
  * (1) 스트림 파이프라인은 소스 스트림에서 시작해 종단 연산으로 끝나며, 그 사이에 하나 이상의 중간 연산이 있을 수 있다.
      * 중간 연산(intermediate operation)
          * 스트림을 어떠한 방식으로든 변환한다.
              * 예) 각 원소에 함수를 적용하거나 특정 조건을 만족하지 못하는 원소를 걸러낸다.
          * 한 스트림을 다른 스틈림으로 변환하는데, 변환 후 스트림의 원소 타입은 변환 전 스트림의 원소 타입과 같거나 다르다.
      * 종단 연산(terminal operation)
          * 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.
              * 예) 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력한다.
          * 종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는 명령어 no-op과 같다.
  * (2) 스트림 파이프라인은 지연 평가(lazy evaluation)된다.
      * 지연 평가: 평가가 종단 연산이 호출될 때 이뤄지며, 종단 연산에 쓰이지 않는 원소는 계산에 쓰이지 않는다.
      * 지연 평가로 인해 무한 스트림을 다룰 수 있다.
  * (3) 스트림 파이프라인 하나를 구성하는 모든 호출을 연결해 하나의 표현식으로 작성할 수 있다.
      * 다시 말해, 스트림 api는 메서드 연쇄를 지원한다.
  * (4) 스트림 파이프라인은 순차적으로 수행된다.
      * 파이프라인 병렬 실행하면 파이프라인 구성 스트림 중 하나에서 parallel 메서드 호출해주면 된다.

## 스트림은 언제 써야 하는가?
확고부동한 규칙은 없지만 노하우는 있다!
### 예) 아나그램(anagram) 그룹 출력 코드
* 아나그램: 철자를 구성하는 알파벳이 같으면서, 순서만 다른 단어
* 사전 파일에서 단어를 읽어 사용자가 지정한 문턱값보다 원소 수가 많은 아나그램 출력하는 프로그램
    * 사용자가 명시한 사전파일에서 각 단어를 읽어 맵에 저장
        * key: 단어를 구성하는 철자들의 알파벳순 정렬 값 (예: “aelpst” → [“staple”, “petals”])
    * 맵의 values() 메서드로 아나그램 집합들을 얻어, 원소 수가 문턱값보다 많은 집합들을 출력함
#### 스트림 사용하지 않은 예)
[Anagrams1.java](..%2F..%2F..%2Fmain%2Fjava%2Fch07%2Fitem45%2FAnagrams1.java)
##### 참고) `computeIfAbsent`
```
V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)
```
* `Map` 인터페이스에서 제공하는 메서드
* 주어진 키에 대해 값이 존재하지 않으면 새로운 값을 계산하여 추가하는 기능
    - `key`: 찾고자 하는 키
    - `mappingFunction`: 키에 해당하는 값이 없을 경우 실행할 함수 (새로운 값 생성)
- 동작
    - `Map`에서 `key`를 찾는다.
    - `key`가 이미 존재하면 기존 값을 반환한다.
    - `key`가 존재하지 않으면 `mappingFunction`을 실행하여 새로운 값을 계산한 후, 이를 `Map`에 추가하고 반환한다.
- 장점
    - 키에 다수의 값을 매핑하는 맵을 쉽게 구현할 수 있다.
        - if-else 없이 존재여부 체크하고 값 생성 가능
        - 키 없을 때만 새 값 추가하므로 불필요한 재할당 방지
    - 기존 값 재사용하므로 put 여러번 호출하는 것보다 효율적
```java
Map<String, List<String>> map = new HashMap<>();

// "fruit" 키가 없으면 새로운 ArrayList 생성 후 "apple" 추가
map.computeIfAbsent("fruit", k -> new ArrayList<>()).add("apple");

// "fruit" 키가 이미 있으므로 기존 리스트를 반환하고 "banana" 추가
map.computeIfAbsent("fruit", k -> new ArrayList<>()).add("banana");

// "vegetable" 키가 없으므로 새로운 ArrayList 생성 후 "carrot" 추가
map.computeIfAbsent("vegetable", k -> new ArrayList<>()).add("carrot");

System.out.println(map); // {fruit=[apple, banana], vegetable=[carrot]}
```

#### 스트림을 과도하게 사용한 예)
[Anagrams2.java](..%2F..%2F..%2Fmain%2Fjava%2Fch07%2Fitem45%2FAnagrams2.java)
* 스트림을 과도하게 사용할 경우 코드 가독성과 유지보수 측면에서 손해를 볼 수 있다.

#### 스트림을 적당하게 사용한 예)
[Anagrams3.java](..%2F..%2F..%2Fmain%2Fjava%2Fch07%2Fitem45%2FAnagrams3.java)
* 모든 반복문을 스트림으로 바꾸고 싶은 유혹을 느낄 수도 있지만…
* 기존 코드는 스트림을 사용하도록 리팩토링하되, 리팩토링 한 것이 나을 때만 반영하자.
##### 참고) char 값들을 처리할 때는 스트림을 삼가는 편이 낫다!
[CharWithStreamTest.java](..%2F..%2F..%2Fmain%2Fjava%2Fch07%2Fitem45%2FCharWithStreamTest.java)

## 스트림으로 리팩토링하는 것이 좋은 경우
* 원소들의 시퀀스를...
    * 일관되게 변환하는 경우
    * 필터링하는 경우
    * 하나의 연산을 사용해 결합하는 경우(더하기, 연결하기, 최솟값 구하기 등)
    * 컬렉션에 모으는 경우 (공통된 속성을 기준으로 묶어가며)
* 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는 경우

## 스트림으로 리팩토링 하는 것이 맞지 않는 경우
### (1) 함수 객체로는 할 수 없지만 코드 블록에서는 할 수 있는 일들의 경우
* 코드 블록에서는 범위 안의 지역변수를 수정할 수 있다.
    * 하지만 람다에서는 final이거나 사실상 final인 변수만 읽을 수 있고, 지역 변수를 수정하는 것이 불가능하다.
* 코드 블록에서는 return문을 이용해 메서드에서 빠져나가거나 break, continue로 블록 바깥의 반복문을 종료하거나 반복을 건너뛸 수 있다.
    * 람다는 할 수 없다.
* 코드 블록에서는 메서드 선언에 명시된 검사 예외를 던질 수 있다.
    * 람다는 할 수 없다.

### (2) 스트림으로 처리하기 어려운 일들의 경우
* 한 데이터가 파이프라인의 여러 단계(stage)를 통과할 때, 이 데이터의 각 단계에서의 값들에 동시 접근해야할 때
    * 스트림 파이프라인은 일단 한 값을 다른 값에 매핑하고 나면 원래 값을 잃는 구조이기 때문
    * 우회 방법
        * 원래 값과 새로운 값의 쌍을 저장하는 객체를 사용해 매핑하기?
        * 만족스러운 방식은 아니다.
            * 코드 양도 많고 지저분하여 스트림을 쓰는 주목적에서 어긋난다.
            * 매핑 객체가 필요한 단계가 여러곳이라면 더욱 그렇다.
#### 예) 메르센 소수 출력 코드
* 메르센 수: 2^p -1 형태의 수
    * 메르센 소수(Mersenne prime): p가 1이면 해당 메르센 수도 소수일 수 있는데, 이 때의 수를 메르센 소수라 한다.
* [MersennePrimes.java](..%2F..%2F..%2Fmain%2Fjava%2Fch07%2Fitem45%2FMersennePrimes.java)

## 스트림과 반복문 중 무엇을 써야할지 바로 알기 어려운 경우 → 취향과 개발 환경에 따라 결정
### 예) 카드 덱 초기화 작업 수행하는 코드
* 카드 덱을 초기화하는 작업
    * 조건: 카드는 숫자(rank), 무늬(suit)를 묶은 불변 값 클래스이면서 숫자와 무늬가 모두 열거타입인 경우
    * 숫자, 무늬 두 집합의 원소로 만들 수 있는 가능한 모든 조합의 계산 (데카르트의 곱)
* [Card.java](..%2F..%2F..%2Fmain%2Fjava%2Fch07%2Fitem45%2FCard.java)

- - - 
* 참고) [[Stream API의 map()과 flatMap()]]


