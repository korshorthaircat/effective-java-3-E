# 공유 중인 가변 데이터는 동기화해 사용하라
> 여러 스레드가 가변 데이터를 공유한다면, 그 데이터를 일고 쓰는 동작은 반드시 동기화해야 한다.
> 동기화하지 않으면 한 스레드가 수행한 변경을 다른 스레드가 보지 못하게 된다.
> 공유되는 가변 데이터를 동기화하는데 실패하면 → 응답불가 상태에 빠지거나 안전실패로 이어질 수 있다. (디버깅 난이도 가장 높은 문제. 간헐적으로 문제 생길 수 있고, VM에 따라 현상 달라짐)
> 배타적 실행은 필요 없고 스레드끼리 통신만 필요하면 volatile 한정자만으로 동기화할 수 있다.
> 	다만 올바로 사용하기 까다롭다.
- - - 
## Synchronized
* 이 키워드는, 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다.

## 동기화의 기능
### 동기화의 기능 - (1) 배타적 실행

* (많은 프로그래머가 동기화에 대해 이해하는 지점)
* 한 스레드가 변경하는 중이라 상태가 일관되지 않은 순간의 객체를, 다른 스레드가 보지 못하게 막는다.
    * 한 객체가 일관된 상태를 가지고, [[17. 변경 가능성을 최소화하라]]
    * 이 객체에 접근하는 메서드는 그 객체에 락을 건다.
    * 락을 건 메서드는 객체의 상태를 확인하고 필요하면 수정한다. (객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화시킨다.)
* 동기화를 제대로 사용하면 어떤 메서드도 이 객체의 일관되지 않은 순간을 볼 수 없다.

### 동기화의 기능 - (2) 스레드간 안정적인 통신
* 동기화된 메서드나 블록에 들어간 스레드가, 같은 락의 보호하에 수행된 모든 이전 수정의 최종결과를 보게 해준다.
* 즉, 한 스레드가 만든 변화를 다른 스레드에서 확인할 수 있게 한다.
* 동기화는 배타적 실행에서뿐만 아니라, 스레드 사이의 안정적 통신에 꼭 필요하다.
    * 자바 언어 명세에서 (long, double 외의) 변수를 읽고 쓰는 동작은 원자적이다.
        * 즉, 여러 스레드가 같은 변수를 동기화없이 수정하는 중이더라도, 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장한다. 스레드가 필드를 읽을 때 항상 ‘수정이 완전히 반영된’ 값을 얻는다고 보장한다.
    * 하지만 한 스레드가 저장한 값이 다른 스레드에게 ‘보이는가’는 보장하지 않는다.’
* 공유적인 가변 데이터를 원자적으로 읽고 쓸 수 있을지라도, 동기화에 실패할시 문제가 발생할 수 있다.
    * 예) 스레드를 멈추는 작업
        * `Thread.stop`메서드는 안전하지 않아 이미 오래전 deprecated되었다. 사용하지 말자!
    * 스레드를 멈추는 올바른 방법
        * 첫번째 스레드는 자신의 boolean 필드를 폴링하면서, 그 값이 true가 되면 멈춘다.
        * 이 필드를 false로 초기화해놓고, 다른 스레드에서 이 스레드를 멈추고자 할 때 true로 변경하는 방식
    * 스레드를 멈추기 위하여, 공유 중인 가변 데이터에 접근할 때 동기화를 제거하면 어떻게 되는가?(boolean 필드를 읽고 쓰는 작업이 원자적이라, 동기화를 제거해도 되는가? → no)
### 예) 잘못된 코드! - 공유 중인 가변 데이터에 접근할 때 동기화 없는 경우
[StopThread1.java](..%2F..%2F..%2Fmain%2Fjava%2Fch11%2Fbroken%2FStopThread1.java)

### 예) 수정한 코드 1 - 공유 중인 가변 데이터에 대한 읽기, 쓰기 동기화
[StopThread.java](..%2F..%2F..%2Fmain%2Fjava%2Fch11%2Ffixed1%2FStopThread.java)

### 예) 수정한 코드 2 - volatile
[StopThread.java](..%2F..%2F..%2Fmain%2Fjava%2Fch11%2Ffixed2%2FStopThread.java)

### volatile 사용시 유의
#### 예) 잘못된 코드 - 안전 실패(safety failure)
[SerialNumber.java](..%2F..%2F..%2Fmain%2Fjava%2Fch11%2Fbroken%2FSerialNumber.java)

#### 예) 수정한 코드
[SerialNumber.java](..%2F..%2F..%2Fmain%2Fjava%2Fch11%2Ffixed1%2FSerialNumber.java)
[SerialNumber.java](..%2F..%2F..%2Fmain%2Fjava%2Fch11%2Ffixed3%2FSerialNumber.java)

### volatile vs synchronized
|방법|가시성(Visibility)|원자성(Atomicity)|JIT 최적화 방지|
|---|---|---|---|
|`volatile`|✅ (즉시 메모리에 반영)|❌ (연산 자체는 원자적이지 않음)|✅ (JIT 최적화 방지 가능)|
|`synchronized`|✅ (동기화된 접근 보장)|✅ (임계 구역 보호)|✅ (JIT 최적화 방지 가능)|

- `volatile`만 사용하면 단순한 **읽기-쓰기 가시성 문제**는 해결되지만, **원자성이 필요한 경우에는 여전히 문제가 발생할 수 있음**.
- `synchronized`를 사용하면 **가시성과 원자성 모두 보장**되므로, 이 경우에는 더 안전한 방법이 될 수 있음.
